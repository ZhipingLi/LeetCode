/**
 * 最小生成树(Minimum Spanning Tree)算法：
 * 最小生成树算法主要有Prim算法(普里姆算法)和Kruskal算法(克鲁斯卡尔算法)两种，虽然这两种算法都运用了贪心思想，但从实现上来说差异还是比较大。
 * 
 * 「树」和「图」的根本区别：
 * 树不会包含环，图可以包含环，换句话说，树就是「无环连通图」。
 * 
 * 「生成树」：
 * 生成树就是在图中找⼀棵包含图中的所有节点的树，或者说，生成树是含有图中所有顶点的「无环连通子图」。
 * 
 * 「最小生成树」：
 * 对于加权图，每条边都有权重，所以每棵生成树都有⼀个权重和。「最小生成树」即所有可能的生成树中，权重和最小的那棵生成树。
 * PS：⼀般来说，我们都是在无向加权图中计算最小生成树的，所以使用最小生成树算法的现实场景中，图的边权重一般代表成本、距离这样的标量。
 * 
 * Kruskal算法中会使用到Union-Find算法, 其主要作用是保证最小生成树的合法性。
 */

/**
 * 以图判树（本题）：
 * 根据上述定义，树是「无环」的「连通」的图，在代码层面体现为：
 * 「无环」：对于添加的一条边而言，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环。
 * 「连通」：该图中只有一个连通分量。
 */

 const {Union_Find} = require('../../Union-Find（并查集算法）/Union-Find')

/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {boolean}
 */
 var validTree = function(n, edges) {
  const uf = new Union_Find(n)
  // 注意forEach的return问题，优先考虑使用for...of和for...in
  for(const [u, v] of edges){
    /* 无环 */
    if(uf.connected(u, v)) return false
    uf.union(u, v)
  }
  /* 连通 */
  return uf.count() === 1
 }
