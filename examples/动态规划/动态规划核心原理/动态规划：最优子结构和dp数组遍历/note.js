/* 最优子结构 */
/**
 * 最优子结构举例（可以从子问题的最优结果推出更大规模问题的最优结果）：
 * 假设学校有10个班，已知每个班的最高考试成绩。现要求计算全校最高的成绩，只需要在这10个最高成绩中取最大的就是全校的最高成绩。
 * 
 * 非最优子结构举例（无法通过子问题的最优值推出规模更大的问题的最优值）：
 * 假设学校有10个班，已知每个班的最大分数差（最高分和最低分的差值）。现在要求计算全校学生中的最大分数差，此时不能通过已知的10个班的最大分数差推导出来。
 * 因为这10个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是3班的最高分和6班的最低分之差。
 * 
 * 解决最优子结构失效策略：改造问题
 * 
 * 动态规划就是从最简单的base case往后推导，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。
 * 找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则OK。
 */

/* dp数组的遍历 */
/**
 * dp数组的遍历方向可以是正向、反向、斜向：
 * 已知dp[0...i-1] -> 想办法求出dp[i] （以正向为例）
 * 
 * 确定dp数组的遍历方向策略：
 * 1. 遍历的过程中，所需的状态（dp[0...i-1]）必须是已经计算出来的；
 * 2. 遍历的终点（dp[n - 1]）必须是存储结果的那个位置。
 * 
 * 如果无法通过dp[0...i-1]推导出dp[i]：
 * 1. 可能dp数组的定义不够恰当，需要重新定义dp数组的含义；
 * 2. 可能dp数组存储的信息还不够，不足以推出下一步的答案，需要把dp数组扩大成二维数组甚至三维数组。
 */
 
