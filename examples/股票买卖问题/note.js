/**
 * 股票买卖问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态。
 * 
 * 使用一个三维数组就可以装下这几种状态的全部组合：
 * dp[i][k][0 or 1]
 * n（0 <= i <= n - 1）为天数，K（1 <= k <= K）为交易数的上限，0 和 1 代表是否持有股票。
 * 此问题共n × K × 2种状态。
 * 
 * 每天都有三种「选择」：买入（buy）、卖出（sell）、无操作（rest）
 * 
 * 「选择」限制：
 * 1. sell必须在buy之后，buy必须在sell之后。
 * 2. rest操作分两种状态，一种是buy之后的rest（持有股票），一种是sell之后的rest（未持有股票）。
 * 3. 交易次数 k 的限制，也就是说buy只能在k > 0的前提下操作。
 * 
 * 注意：
 * 1. k的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。
 *    如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为k，那么昨天的最大交易次数上限则为k - 1。
 * 2. 在sell的时候给 k 减小 1 和在buy的时候给 k 减小 1 并非等效的。
 *    如果buy的选择不改变交易次数k的约束，会出现交易次数超出限制的错误。
 * 3. 最终答案是dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得的利润。
 *    因为dp[n - 1][K][1]代表到最后一天手上还持有股票，dp[n - 1][K][0]表示最后一天手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。
 */
 
/** base case:
 * dp[-1][...][0] = 0
 * 解释：i 是从 0 开始的，所以 i = -1 意味着还没有开始，此时利润为 0。
 * 
 * dp[-1][...][1] = -Infinity
 * 解释：还没开始的时，是不可能持有股票的。算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
 * 
 * dp[...][0][0] = 0
 * 解释：k 是从 1 开始的，所以 k = 0 意味着不能再买入股票了，此时利润为 0。
 * 
 * dp[...][0][1] = price[i]
 * 解释：此时不能再买入股票了，但可以卖出股票，按当天的股票价格卖出。因为k - 1发生在买入股票时。
 */
 
/** 状态转移方程
 * dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
 *               max( 今天选择 rest, 今天选择 sell )
 * 解释：今天未持有股票，有两种可能，从这两种可能中求最大利润：
 * 1. 昨天未持有股票，且截止昨天最大交易次数限制为k；然后今天选择rest，故今天还是未持有，最大交易次数限制依然为k。
 * 2. 昨天持有股票，且截止昨天最大交易次数限制为k；但是今天sell了，故今天未持有股票了，最大交易次数限制依然为k。
 * 
 * dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
 *               max( 今天选择 rest, 今天选择 buy )
 * 解释：今天持有股票，最大交易次数限制为 k，那么对于昨天来说，有两种可能，从这两种可能中求最大利润：
 * 1. 昨天持有股票，且截止昨天最大交易次数限制为k；然后今天选择rest，故今天仍持有股票，最大交易次数限制依然为k。
 * 2. 昨天未持有股票，且截止昨天最大交易次数限制为k - 1；但是今天buy了，故今天持有股票了，最大交易次数限制为k。
 */
 